<?xml version="1.0"?>
<doc>
    <assembly>
        <name>adimus.ertus.Logger</name>
    </assembly>
    <members>
        <member name="T:adimus.ertus.Logger.AsyncRollingFileAppender">
            <summary>
              Appender that rolls log files based on size or date or both.
              Log files are written to asynchronously.
            </summary>
            <remarks>
              <para>
                AsyncRollingFileAppender can function as either or and do both
                at the same time (making size based rolling files until a data/time 
                boundary is crossed at which time it rolls all of those files
                based on the setting for <see cref="P:adimus.ertus.Logger.AsyncRollingFileAppender.RollingStyle"/>.
              </para>
              <para>
                A of few additional optional features have been added:<br/>
                -- Attach date pattern for current log file <see cref="P:adimus.ertus.Logger.AsyncRollingFileAppender.StaticLogFileName"/><br/>
                -- Backup number increments for newer files <see cref="P:adimus.ertus.Logger.AsyncRollingFileAppender.CountDirection"/><br/>
                -- Infinite number of backups by file size <see cref="P:adimus.ertus.Logger.AsyncRollingFileAppender.MaxSizeRollBackups"/>
              </para>
              <para>
                A few notes and warnings:  For large or infinite number of backups
                countDirection &gt; 0 is highly recommended, with staticLogFileName = false if
                time based rolling is also used -- this will reduce the number of file renamings
                to few or none.  Changing <c>staticLogFileName</c> or <c>countDirection</c> without
                clearing the directory could have nasty side effects.  If Date/Time based rolling
                is enabled, <c>CompositeRollingAppender</c> will attempt to roll existing files
                in the directory without a date/time tag based on the last modified date
                of the base log files last modification.
              </para>
              <para>
                A maximum number of backups based on date/time boundaries would be nice
                but is not yet implemented.
              </para>
            </remarks>
            <summary>
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.AsyncRollingFileAppender.#ctor">
            <summary>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:adimus.ertus.Logger.AsyncRollingFileAppender.Close" -->
        <member name="M:adimus.ertus.Logger.AsyncRollingFileAppender.DoAppend(log4net.Core.LoggingEvent)">
            <summary>
            </summary>
            <param name = "loggingEvent"></param>
        </member>
        <member name="P:adimus.ertus.Logger.AsyncRollingFileAppender.Name">
            <summary>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:adimus.ertus.Logger.AsyncRollingFileAppender.ImmediateFlush" -->
        <member name="P:adimus.ertus.Logger.AsyncRollingFileAppender.AppendToFile">
            <summary>
              AppendToFile is a flag that indicates weather the file should be
              appended to or overwritten. If the value is set to false then the
              file will be overwritten. If it is set to true then the file will
              be appended to. The default value is true.
            </summary>
        </member>
        <member name="P:adimus.ertus.Logger.AsyncRollingFileAppender.CountDirection">
            <summary>
              Number rolling file count direction. Either positive or negative.
              Indicates if the current file is the lowest numbered file or the
              highest numbered file.
            </summary>
        </member>
        <member name="P:adimus.ertus.Logger.AsyncRollingFileAppender.Encoding">
            <summary>
              The <see cref="P:adimus.ertus.Logger.AsyncRollingFileAppender.Encoding"/> used to write to the file
            </summary>
            <value>
              The <see cref="P:adimus.ertus.Logger.AsyncRollingFileAppender.Encoding"/> used to write to the file
            </value>
        </member>
        <member name="P:adimus.ertus.Logger.AsyncRollingFileAppender.File">
            <summary>
              <see cref="P:adimus.ertus.Logger.AsyncRollingFileAppender.File"/> is the path to the file that logging will be written to
            </summary>
            <value>
              <see cref="P:adimus.ertus.Logger.AsyncRollingFileAppender.File"/> is the path to the file that logging will be written to
            </value>
            <remarks>
              <para><see cref="P:adimus.ertus.Logger.AsyncRollingFileAppender.File"/> is the path to the file that logging 
                will be written to.</para>
            
              <para>If the path is relative it is taken as relative from 
                the <see cref="P:System.AppDomain.BaseDirectory"/> path.</para>
            </remarks>
        </member>
        <member name="P:adimus.ertus.Logger.AsyncRollingFileAppender.MaxFileSize">
            <summary>
              Get the maximum size that the output file is allowed to reach
              before being rolled over to backup files.
              <para>This method is equivalent to <see cref="P:adimus.ertus.Logger.AsyncRollingFileAppender.MaximumFileSize"/> except
                that it is required for differentiating the setter taking a
                <see cref="T:System.Int64"/> argument from the setter taking a
                <see cref="T:System.String"/> argument.</para>
            </summary>
        </member>
        <member name="P:adimus.ertus.Logger.AsyncRollingFileAppender.MaxSizeRollBackups">
            <summary>
              Returns the value of the <b>maxSizeRollBackups</b> option.
            </summary>
            <remarks>
              <para>The <b>MaxSizeRollBackups</b> option determines how many backup
                files are kept before the oldest is erased. This option takes
                an integer value. If set to zero, then there will be no
                backup files and the log file will be truncated when it reaches
                <see cref="P:adimus.ertus.Logger.AsyncRollingFileAppender.MaxFileSize"/>.  If a negative number is supplied then
                no deletions will be made.  Note that this could result in
                very slow performance as a large number of files are rolled over unless
                <see cref="P:adimus.ertus.Logger.AsyncRollingFileAppender.CountDirection"/> up is used.</para>
            
              <para>The maximum applies to <b>each</b> time based group of files and <b>not</b> the total.
                Using a daily roll the maximum total files would be <c>(#days run) * (maxSizeRollBackups)</c>
              </para>
            </remarks>
        </member>
        <member name="P:adimus.ertus.Logger.AsyncRollingFileAppender.MaximumFileSize">
            <summary>
              Set the maximum size that the output file is allowed to reach
              before being rolled over to backup files.
            
              <para>In configuration files, the <b>MaxFileSize</b> option takes an
                long integer in the range 0 - 2^63. You can specify the value
                with the suffixes "KB", "MB" or "GB" so that the integer is
                interpreted being expressed respectively in kilobytes, megabytes
                or gigabytes. For example, the value "10KB" will be interpreted
                as 10240.</para>
            </summary>
        </member>
        <member name="P:adimus.ertus.Logger.AsyncRollingFileAppender.RollingStyle">
            <summary>
              Set the rolling style
            </summary>
        </member>
        <member name="P:adimus.ertus.Logger.AsyncRollingFileAppender.StaticLogFileName">
            <summary>
              Set the m_staticLogFileName flag
            </summary>
        </member>
        <member name="T:adimus.ertus.Logger.AsyncFileAppender">
            <summary>
            Appends logging events asynchronously to a file.
            </summary>	
            <remarks>
            Provides an asynchronous file appender so there is no locking of 
            log file with a multiprocessor box.
            
            The file can be opened in either append or
            overwrite mode.
            </remarks>
        </member>
        <member name="T:adimus.ertus.Logger.FileStreamAppender">
            <summary>
            Sends logging events to a <see cref="T:System.IO.FileStream"/>.
            </summary>
            <remarks>
            An Appender that writes to a <see cref="T:System.IO.FileStream"/>.
            </remarks>
        </member>
        <member name="F:adimus.ertus.Logger.FileStreamAppender.REVISION">
            <summary>
            Revision of class as set by source control.
            </summary>		
        </member>
        <member name="F:adimus.ertus.Logger.FileStreamAppender.qsw">
            <summary>
            This is the <see cref="T:adimus.ertus.Logger.QuietStreamWriter"/> where logging events
            will be written to. 
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.FileStreamAppender.encoding">
            <summary>
            The encoding to use for the text writing to the stream.
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.FileStreamAppender.#ctor">
            <summary>
            Constructor
            </summary>		
        </member>
        <member name="M:adimus.ertus.Logger.FileStreamAppender.PreAppendCheck">
            <summary>
            This method determines if there is a sense in attempting to append.
            </summary>
            <remarks>
            <para>
            This method checked if an output target has been set and if a
            layout has been set. 
            </para>
            </remarks>
            <returns><c>false</c> if any of the preconditions fail.</returns>
        </member>
        <member name="M:adimus.ertus.Logger.FileStreamAppender.Append(log4net.Core.LoggingEvent)">
            <summary>
            This method is called by the <see cref="M:log4net.Appender.AppenderSkeleton.DoAppend(log4net.Core.LoggingEvent)"/>
            method. 
            </summary>
            <param name="loggingEvent">The event to log.</param>
            <remarks>
            <para>
            Writes a log statement to the output stream if the output stream exists 
            and is writable.  
            </para>
            <para>
            The format of the output will depend on the appender's layout.
            </para>
            </remarks>
        </member>
        <member name="M:adimus.ertus.Logger.FileStreamAppender.OnClose">
            <summary>
            Close this appender instance. The underlying stream or writer is also closed.
            </summary>
            <remarks>
            Closed appenders cannot be reused.
            </remarks>
        </member>
        <member name="M:adimus.ertus.Logger.FileStreamAppender.WriteFooterAndCloseWriter">
            <summary>
            Writes the footer and closes the underlying <see cref="T:System.IO.TextWriter"/>.
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.FileStreamAppender.CloseWriter">
            <summary>
            Closes the underlying <see cref="T:System.IO.TextWriter"/>.
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.FileStreamAppender.Reset">
            <summary>
            Clears internal references to the underlying <see cref="T:System.IO.TextWriter"/> 
            and other variables.
            </summary>
            <remarks>
            Subclasses can override this method for an alternate closing behaviour.
            </remarks>
        </member>
        <member name="M:adimus.ertus.Logger.FileStreamAppender.WriteFooter">
            <summary>
            Writes a footer as produced by the embedded layout's <see cref="P:log4net.Layout.ILayout.Footer"/> property.
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.FileStreamAppender.WriteHeader">
            <summary>
            Writes a header produced by the embedded layout's <see cref="P:log4net.Layout.ILayout.Header"/> property.
            </summary>
        </member>
        <member name="P:adimus.ertus.Logger.FileStreamAppender.Encoding">
            <summary>
            Gets or sets <see cref="P:adimus.ertus.Logger.FileStreamAppender.Encoding"/> used to write to the file.
            </summary>
            <value>
            The <see cref="P:adimus.ertus.Logger.FileStreamAppender.Encoding"/> used to write to the file.
            </value>
        </member>
        <member name="P:adimus.ertus.Logger.FileStreamAppender.Stream">
            <summary>
            Sets the <see cref="T:System.IO.FileStream"/> where the log output will go.
            </summary>
            <remarks>
            <para>
            The specified <see cref="T:System.IO.FileStream"/> must setup appropriately ahead of time.
            </para>
            <para>
            The <see cref="T:System.IO.FileStream"/> will be closed when the appender 
            instance is closed.
            </para>
            <para>
            <b>Note:</b> Logging to an unopened <see cref="T:System.IO.FileStream"/> will fail.
            </para>
            </remarks>
        </member>
        <member name="P:adimus.ertus.Logger.FileStreamAppender.ErrorHandler">
            <summary>
            Gets or set the <see cref="T:log4net.Core.IErrorHandler"/> and the underlying 
            <see cref="T:log4net.Util.QuietTextWriter"/>, if any, for this appender. 
            </summary>
            <value>
            The <see cref="T:log4net.Core.IErrorHandler"/> for this appender.
            </value>
        </member>
        <member name="P:adimus.ertus.Logger.FileStreamAppender.RequiresLayout">
            <summary>
            This appender requires a Layout to be set.
            </summary>
            <value><c>true</c></value>
        </member>
        <member name="F:adimus.ertus.Logger.AsyncFileAppender.appendToFile">
            <summary>
            Flag to indicate if we should append to the file
            or overwrite the file. The default is to append.
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.AsyncFileAppender.fileName">
            <summary>
            The name of the log file.
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.AsyncFileAppender.#ctor">
            <summary>
            Constructor
            </summary>		
        </member>
        <member name="M:adimus.ertus.Logger.AsyncFileAppender.#ctor(log4net.Layout.ILayout,System.String)">
            <summary>
            Construct a new appender using the layout and file specified.
            The file will be appended to.
            </summary>
            <param name="layout">the layout to use with this appender</param>
            <param name="filename">the full path to the file to write to</param>
        </member>
        <member name="M:adimus.ertus.Logger.AsyncFileAppender.#ctor(log4net.Layout.ILayout,System.String,System.Boolean)">
            <summary>
            Construct a new appender using the layout, file and append mode.
            </summary>
            <param name="layout">the layout to use with this appender</param>
            <param name="filename">the full path to the file to write to</param>
            <param name="append">flag to indicate if the file should be appended to</param>
        </member>
        <member name="M:adimus.ertus.Logger.AsyncFileAppender.ActivateOptions">
            <summary>
            Activate the options on the file appender. This will
            case the file to be opened.
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.AsyncFileAppender.Reset">
            <summary>
            Closes any previously opened file and calls the parent's <see cref="M:adimus.ertus.Logger.FileStreamAppender.Reset"/>.
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.AsyncFileAppender.CloseFile">
            <summary>
            Closes the previously opened file.
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.AsyncFileAppender.OpenFile(System.String,System.Boolean)">
            <summary>
            Sets and <i>opens</i> the file where the log output will
            go. The specified file must be writable.
            </summary>
            <param name="fileName">The path to the log file</param>
            <param name="append">If true will append to fileName. Otherwise will truncate fileName</param>
            <remarks>
            <para>If there was already an opened file, then the previous file
            is closed first.</para>
            
            <para>This method will ensure that the directory structure
            for the <paramref name="fileName"/> specified exists.</para>
            </remarks>
        </member>
        <member name="M:adimus.ertus.Logger.AsyncFileAppender.SetQWForFiles(System.String,System.Boolean)">
            <summary>
            Sets the quiet writer being used.
            </summary>
            <remarks>
            This method can be overridden by sub classes.
            </remarks>
            <param name="stream">the stream to set</param>
        </member>
        <member name="M:adimus.ertus.Logger.AsyncFileAppender.ConvertToFullPath(System.String)">
            <summary>
            Convert a path into a fully qualified path.
            </summary>
            <param name="path">The path to convert.</param>
            <remarks>
            <para>
            Converts the path specified to a fully
            qualified path. If the path is relative it is
            taken as relative from the application base 
            directory.
            </para>
            </remarks>
            <returns>The fully qualified path.</returns>
        </member>
        <member name="P:adimus.ertus.Logger.AsyncFileAppender.File">
            <summary>
            Gets or sets the path to the file that logging will be written to.
            </summary>
            <value>
            The path to the file that logging will be written to.
            </value>
            <remarks>
            <para>
            If the path is relative it is taken as relative from 
            the application base directory.
            </para>
            </remarks>
        </member>
        <member name="P:adimus.ertus.Logger.AsyncFileAppender.AppendToFile">
            <summary>
            Gets or sets a flag that indicates weather the file should be
            appended to or overwritten.
            </summary>
            <value>
            Indicates whether the file should be appended to or overwritten.
            </value>
            <remarks>
            <para>
            If the value is set to false then the file will be overwritten, if 
            it is set to true then the file will be appended to.
            </para>
            The default value is true.
            </remarks>
        </member>
        <member name="T:adimus.ertus.Logger.IDateTime">
            <summary>
            This interface is used to supply Date/Time information to the <see cref="T:adimus.ertus.Logger.ExtendedRollingFileAppender"/>.
            </summary>
            <remarks>
            This interface is used to supply Date/Time information to the <see cref="T:adimus.ertus.Logger.ExtendedRollingFileAppender"/>.
            Used primarily to allow test classes to plug themselves in so they can
            supply test date/times.
            </remarks>
        </member>
        <member name="P:adimus.ertus.Logger.IDateTime.Now">
            <summary>
            This property will return the 'current' time.
            </summary>
        </member>
        <member name="T:adimus.ertus.Logger.RollingMode">
            <summary>
            Style of rolling to use
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.RollingMode.Size">
            <summary>
            Roll files based only on the size of the file
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.RollingMode.Date">
            <summary>
            Roll files based only on the date
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.RollingMode.Composite">
            <summary>
            Roll files based on both the size and date of the file
            </summary>
        </member>
        <member name="T:adimus.ertus.Logger.ExtendedRollingFileAppender">
            <summary>
            Appender that rolls log files based on size or date or both
            </summary>
            <remarks>
            <para>ExtendedRollingFileAppender can function as either or and do both
            at the same time (making size based rolling files until a data/time 
            boundary is crossed at which time it rolls all of those files
            based on the setting for <see cref="F:adimus.ertus.Logger.ExtendedRollingFileAppender.m_rollingStyle"/>.</para>
            
            <para>
            A of few additional optional features have been added:<br/>
            -- Attach date pattern for current log file <see cref="F:adimus.ertus.Logger.ExtendedRollingFileAppender.m_staticLogFileName"/><br/>
            -- Backup number increments for newer files <see cref="F:adimus.ertus.Logger.ExtendedRollingFileAppender.m_countDirection"/><br/>
            -- Infinite number of backups by file size <see cref="F:adimus.ertus.Logger.ExtendedRollingFileAppender.m_maxSizeRollBackups"/>
            </para>
            <para>A few notes and warnings:  For large or infinite number of backups
            countDirection &gt; 0 is highly recommended, with staticLogFileName = false if
            time based rolling is also used -- this will reduce the number of file renamings
            to few or none.  Changing staticLogFileName or countDirection without clearing
            the directory could have nasty side effects.  If Date/Time based rolling
            is enabled, CompositeRollingAppender will attempt to roll existing files
            in the directory without a date/time tag based on the last modified date
            of the base log files last modification.</para>
            <para>A maximum number of backups based on date/time boundaries would be nice
            but is not yet implemented.</para>
            </remarks>
        </member>
        <member name="T:adimus.ertus.Logger.ExtendedFileAppender">
            <summary>
            ExtendedFileAppender appends log events to a file. 
            </summary>
            <remarks>
            Logging events are sent to the file specified.
            The file can be opened in either append or
            overwrite modes.
            </remarks>
        </member>
        <member name="F:adimus.ertus.Logger.ExtendedFileAppender.m_appendToFile">
            <summary>
            Flag to indicate if we should append to the file
            or overwrite the file. The default is to append
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.ExtendedFileAppender.m_fileName">
            <summary>
            The name of the log file.
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.ExtendedFileAppender.m_encoding">
            <summary>
            The encoding to use for the file stream
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedFileAppender.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedFileAppender.#ctor(log4net.Layout.ILayout,System.String,System.Boolean)">
            <summary>
            Construct a new appender using the layout, file and append mode.
            </summary>
            <param name="layout">the layout to use with this appender</param>
            <param name="filename">the full path to the file to write to</param>
            <param name="append">flag to indicate if the file should be appended to</param>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedFileAppender.#ctor(log4net.Layout.ILayout,System.String)">
            <summary>
            Construct a new appender using the layout and file specified.
            The file will be appended to.
            </summary>
            <param name="layout">the layout to use with this appender</param>
            <param name="filename">the full path to the file to write to</param>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedFileAppender.ActivateOptions">
            <summary>
            Activate the options on the file appender. This will
            case the file to be opened.
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedFileAppender.Reset">
            <summary>
            Close any previously opened file and call the parent's <see cref="M:log4net.Appender.TextWriterAppender.Reset"/>
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedFileAppender.ConvertToFullPath(System.String)">
            <summary>
            Convert a path into a fully qualified path
            </summary>
            <param name="path">the path to convert</param>
            <returns>the fully qualified path</returns>
            <remarks>
            <para>Converts the path specified to a fully
            qualified path. If the path is relative it is
            taken as relative from the <see cref="P:System.AppDomain.BaseDirectory"/>
            path.</para>
            </remarks>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedFileAppender.CloseFile">
            <summary>
            Closes the previously opened file.
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedFileAppender.OpenFile(System.String,System.Boolean)">
            <summary>
            Sets and <i>opens</i> the file where the log output will
            go. The specified file must be writable.
            </summary>
            <param name="fileName">The path to the log file</param>
            <param name="append">If true will append to fileName. Otherwise will truncate fileName</param>
            <remarks>
            <para>If there was already an opened file, then the previous file
            is closed first.</para>
            
            <para>This method will ensure that the directory structure
            for the <paramref name="fileName"/> specified exists.</para>
            </remarks>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedFileAppender.SetQWForFiles(System.IO.TextWriter)">
            <summary>
            Sets the quiet writer being used.
            </summary>
            <remarks>
            This method can be overridden by sub classes.
            </remarks>
            <param name="writer">the writer to set</param>
        </member>
        <member name="P:adimus.ertus.Logger.ExtendedFileAppender.File">
            <summary>
            <see cref="P:adimus.ertus.Logger.ExtendedFileAppender.File"/> is the path to the file that logging will be written to
            </summary>
            <value>
            <see cref="P:adimus.ertus.Logger.ExtendedFileAppender.File"/> is the path to the file that logging will be written to
            </value>
            <remarks>
            <para><see cref="P:adimus.ertus.Logger.ExtendedFileAppender.File"/> is the path to the file that logging 
            will be written to.</para>
            
            <para>If the path is relative it is taken as relative from 
            the <see cref="P:System.AppDomain.BaseDirectory"/> path.</para>
            </remarks>
        </member>
        <member name="P:adimus.ertus.Logger.ExtendedFileAppender.AppendToFile">
            <summary>
            AppendToFile is a flag that indicates weather the file should be
            appended to or overwritten. If the value is set to false then the
            file will be overwritten. If it is set to true then the file will
            be appended to. The default value is true.
            </summary>
        </member>
        <member name="P:adimus.ertus.Logger.ExtendedFileAppender.Encoding">
            <summary>
            The <see cref="P:adimus.ertus.Logger.ExtendedFileAppender.Encoding"/> used to write to the file
            </summary>
            <value>
            The <see cref="P:adimus.ertus.Logger.ExtendedFileAppender.Encoding"/> used to write to the file
            </value>
        </member>
        <member name="F:adimus.ertus.Logger.ExtendedRollingFileAppender.baseFileName">
            <summary>
            FileName provided in configuration.  Used for rolling properly
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.ExtendedRollingFileAppender.m_dateTime">
            <summary>
            This object supplies the current date/time.  Allows test code to plug in
            a method to control this class when testing date/time based rolling.
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.ExtendedRollingFileAppender.m_datePattern">
            <summary>
            The date pattern. By default, the pattern is set to <c>".yyyy-MM-dd"</c> meaning daily rollover.
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.ExtendedRollingFileAppender.m_scheduledFilename">
            <summary>
            The actual formatted filename that is currently being written to
            or will be the file transferred to on roll over
            (based on staticLogFileName).
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.ExtendedRollingFileAppender.m_nextCheck">
            <summary>
            The timestamp when we shall next recompute the filename.
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.ExtendedRollingFileAppender.m_now">
            <summary>
            Holds date of last roll over
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.ExtendedRollingFileAppender.m_rollPoint">
            <summary>
            The type of rolling done
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.ExtendedRollingFileAppender.m_maxFileSize">
            <summary>
            The default maximum file size is 10MB
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.ExtendedRollingFileAppender.m_maxSizeRollBackups">
            <summary>
            There is zero backup files by default
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.ExtendedRollingFileAppender.m_curSizeRollBackups">
            <summary>
            How many sized based backups have been made so far
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.ExtendedRollingFileAppender.m_maxTimeRollBackups">
            <summary>
            not yet implemented
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.ExtendedRollingFileAppender.m_countDirection">
            <summary>
            By default newer files have lower numbers
            </summary>
            <remarks>
            By default newer files have lower numbers. (countDirection &lt; 0)
            ie. log.1 is most recent, log.5 is the 5th backup, etc...
            countDirection &gt; 0 does the opposite ie.
            log.1 is the first backup made, log.5 is the 5th backup made, etc.
            For infinite backups use countDirection &gt; 0 to reduce rollOver costs.
            </remarks>
        </member>
        <member name="F:adimus.ertus.Logger.ExtendedRollingFileAppender.m_rollingStyle">
            <summary>
            The rolling mode used in this appender
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.ExtendedRollingFileAppender.m_rollDate">
            <summary>
            Cache flag set if we are rolling by date
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.ExtendedRollingFileAppender.m_rollSize">
            <summary>
            Cache flag set if we are rolling by size
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.ExtendedRollingFileAppender.m_staticLogFileName">
            <summary>
            Flag to indicate if we always log to the same file
            </summary>
            <remarks>
            By default file.log is always the current file.  Optionally
            file.log.yyyy-mm-dd for current formatted datePattern can by the currently
            logging file (or file.log.curSizeRollBackup or even
            file.log.yyyy-mm-dd.curSizeRollBackup) This will make time based roll
            overs with a large number of backups much faster -- it won't have to
            rename all the backups!
            </remarks>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedRollingFileAppender.#ctor">
            <summary>
            The default constructor does nothing
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedRollingFileAppender.SetQWForFiles(System.IO.TextWriter)">
            <summary>
            Sets the quiet writer being used.
            </summary>
            <remarks>
            This method can be overridden by sub classes.
            </remarks>
            <param name="writer">the writer to set</param>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedRollingFileAppender.Append(log4net.Core.LoggingEvent)">
            <summary>
            Handles append time behaviour for CompositeRollingAppender.  This checks
            if a roll over either by date (checked first) or time (checked second)
            is need and then appends to the file last.
            </summary>
            <param name="loggingEvent"></param>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedRollingFileAppender.WriteFooter">
            <summary>
            Write the footer of a log file.
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedRollingFileAppender.OnClose">
            <summary>
            Close all writers in appender.
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedRollingFileAppender.OpenFile(System.String,System.Boolean)">
            <summary>
            Creates and opens the file for logging.  If <see cref="F:adimus.ertus.Logger.ExtendedRollingFileAppender.m_staticLogFileName"/>
            is false then the fully qualified name is determined and used.
            </summary>
            <param name="fileName">the name of the file to open</param>
            <param name="append">true to append to existing file</param>
            <remarks>
            <para>This method will ensure that the directory structure
            for the <paramref name="fileName"/> specified exists.</para>
            </remarks>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedRollingFileAppender.DetermineCurSizeRollBackups">
            <summary>
            Determines curSizeRollBackups (only within the current rollpoint)
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedRollingFileAppender.GetWildcardPatternForFile(System.String)">
            <summary>
            Generates a wildcard pattern that can be used to find all files
            that are similar to the base file name.
            </summary>
            <param name="baseFileName"></param>
            <returns></returns>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedRollingFileAppender.GetExistingFiles(System.String)">
            <summary>
            Builds a list of filenames for all files matching the base filename plus a file
            pattern.
            </summary>
            <param name="baseFilePath"></param>
            <returns></returns>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedRollingFileAppender.RollOverIfDateBoundaryCrossing">
            <summary>
            Initiates a roll over if needed for crossing a date boundary since the last run.
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedRollingFileAppender.ExistingInit">
            <summary>
            <para>Initializes based on existing conditions at time of <see cref="M:adimus.ertus.Logger.ExtendedRollingFileAppender.ActivateOptions"/>.
            The following is done:</para>
            	A) determine curSizeRollBackups (only within the current rollpoint)
            	B) initiates a roll over if needed for crossing a date boundary since the last run.
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedRollingFileAppender.InitializeFromOneFile(System.String,System.String)">
            <summary>
            Does the work of bumping the 'current' file counter higher
            to the highest count when an incremental file name is seen.
            The highest count is either the first file (when count direction
            is greater than 0 ) or the last file (when count direction less than 0).
            In either case, we want to know the highest count that is present.
            </summary>
            <param name="baseFile"></param>
            <param name="curFileName"></param>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedRollingFileAppender.InitializeRollBackups(System.String,System.Collections.ArrayList)">
            <summary>
            Takes a list of files and a base file name, and looks for 
            'incremented' versions of the base file.  Bumps the max
            count up to the highest count seen.
            </summary>
            <param name="baseFile"></param>
            <param name="arrayFiles"></param>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedRollingFileAppender.ComputeCheckPeriod">
            <summary>
            Calculates the RollPoint for the m_datePattern supplied.
            </summary>
            <returns>The RollPoint that is most accurate for the date pattern supplied</returns>
            <remarks>
            Essentially the date pattern is examined to determine what the
            most suitable roll point is. The roll point chosen is the roll point
            with the smallest period that can be detected using the date pattern
            supplied. i.e. if the date pattern only outputs the year, month, day 
            and hour then the smallest roll point that can be detected would be
            and hourly roll point as minutes could not be detected.
            </remarks>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedRollingFileAppender.ActivateOptions">
            <summary>
            Sets initial conditions including date/time roll over information, first check,
            scheduledFilename, and calls <see cref="M:adimus.ertus.Logger.ExtendedRollingFileAppender.ExistingInit"/> to initialize
            the current number of backups.
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedRollingFileAppender.RollOverTime">
            <summary>
            Rollover the file(s) to date/time tagged file(s).
            Opens the new file (through setFile) and resets curSizeRollBackups.
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedRollingFileAppender.RollFile(System.String,System.String)">
            <summary>
            Renames file <paramref name="from"/> to file <paramref name="to"/>.  It
            also checks for existence of target file and deletes if it does.
            </summary>
            <param name="from"></param>
            <param name="to"></param>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedRollingFileAppender.DeleteFile(System.String)">
            <summary>
            Delete's the specified file if it exists
            </summary>
            <param name="fileName">the file name to delete</param>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedRollingFileAppender.RollOverSize">
            <summary>
            Implements roll overs base on file size.
            </summary>
            <remarks>
            <para>If the maximum number of size based backups is reached
            (<c>curSizeRollBackups == maxSizeRollBackups</c>) then the oldest
            file is deleted -- it's index determined by the sign of countDirection.
            If <c>countDirection</c> &lt; 0, then files
            {<c>File.1</c>, ..., <c>File.curSizeRollBackups -1</c>}
            are renamed to {<c>File.2</c>, ...,
            <c>File.curSizeRollBackups</c>}.	 Moreover, <c>File</c> is
            renamed <c>File.1</c> and closed.</para>
            
            A new file is created to receive further log output.
            
            <para>If <c>maxSizeRollBackups</c> is equal to zero, then the
            <c>File</c> is truncated with no backup files created.</para>
            
            <para>If <c>maxSizeRollBackups</c> &lt; 0, then <c>File</c> is
            renamed if needed and no files are deleted.</para>
            </remarks>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedRollingFileAppender.NextCheckDate(System.DateTime)">
            <summary>
            Roll on to the next interval after the date passed
            </summary>
            <param name="currentDateTime">the current date</param>
            <returns>the next roll point an interval after the currentDateTime date</returns>
            <remarks>
            Advances the date to the next roll point after the 
            currentDateTime date passed to the method.
            </remarks>
        </member>
        <member name="M:adimus.ertus.Logger.ExtendedRollingFileAppender.NextCheckDate(System.DateTime,adimus.ertus.Logger.ExtendedRollingFileAppender.RollPoint)">
            <summary>
            Roll on to the next interval after the date passed
            </summary>
            <param name="currentDateTime">the current date</param>
            <param name="rollPoint">the type of roll point we are working with</param>
            <returns>the next roll point an interval after the currentDateTime date</returns>
            <remarks>
            Advances the date to the next roll point after the 
            currentDateTime date passed to the method.
            </remarks>
        </member>
        <member name="P:adimus.ertus.Logger.ExtendedRollingFileAppender.Now">
            <summary>
            This property will return the 'current' time.
            </summary>
        </member>
        <member name="P:adimus.ertus.Logger.ExtendedRollingFileAppender.DatePattern">
            <summary>
            The <b>DatePattern</b> takes a string in the same format as
            expected by <see cref="T:log4net.DateFormatter.SimpleDateFormatter"/>. 
            This options determines the rollover schedule.
            </summary>
        </member>
        <member name="P:adimus.ertus.Logger.ExtendedRollingFileAppender.MaxSizeRollBackups">
            <summary>
            Returns the value of the <b>maxSizeRollBackups</b> option.
            </summary>
            <remarks>
            <para>The <b>MaxSizeRollBackups</b> option determines how many backup
            files are kept before the oldest is erased. This option takes
            an integer value. If set to zero, then there will be no
            backup files and the log file will be truncated when it reaches
            <see cref="P:adimus.ertus.Logger.ExtendedRollingFileAppender.MaxFileSize"/>.  If a negative number is supplied then
            no deletions will be made.  Note that this could result in
            very slow performance as a large number of files are rolled over unless
            <see cref="P:adimus.ertus.Logger.ExtendedRollingFileAppender.CountDirection"/> up is used.</para>
            
            <para>The maximum applies to <b>each</b> time based group of files and <b>not</b> the total.
            Using a daily roll the maximum total files would be <c>(#days run) * (maxSizeRollBackups)</c>
            </para>
            </remarks>
        </member>
        <member name="P:adimus.ertus.Logger.ExtendedRollingFileAppender.MaxFileSize">
            <summary>
            Get the maximum size that the output file is allowed to reach
            before being rolled over to backup files.
            <para>This method is equivalent to <see cref="P:adimus.ertus.Logger.ExtendedRollingFileAppender.MaximumFileSize"/> except
            that it is required for differentiating the setter taking a
            <see cref="T:System.Int64"/> argument from the setter taking a
            <see cref="T:System.String"/> argument.</para>
            </summary>
        </member>
        <member name="P:adimus.ertus.Logger.ExtendedRollingFileAppender.MaximumFileSize">
            <summary>
            Set the maximum size that the output file is allowed to reach
            before being rolled over to backup files.
            
            <para>In configuration files, the <b>MaxFileSize</b> option takes an
            long integer in the range 0 - 2^63. You can specify the value
            with the suffixes "KB", "MB" or "GB" so that the integer is
            interpreted being expressed respectively in kilobytes, megabytes
            or gigabytes. For example, the value "10KB" will be interpreted
            as 10240.</para>
            </summary>
        </member>
        <member name="P:adimus.ertus.Logger.ExtendedRollingFileAppender.File">
            <summary>
            <see cref="P:adimus.ertus.Logger.ExtendedRollingFileAppender.File"/> is the path to the file that logging will be written to
            </summary>
            <value>
            <see cref="P:adimus.ertus.Logger.ExtendedRollingFileAppender.File"/> is the path to the file that logging will be written to
            </value>
            <remarks>
            <para><see cref="P:adimus.ertus.Logger.ExtendedRollingFileAppender.File"/> is the path to the file that logging 
            will be written to.</para>
            
            <para>If the path is relative it is taken as relative from 
            the <see cref="P:System.AppDomain.BaseDirectory"/> path.</para>
            </remarks>
        </member>
        <member name="P:adimus.ertus.Logger.ExtendedRollingFileAppender.CountDirection">
            <summary>
            Number rolling file count direction. Either positive or negative.
            Indicates if the current file is the lowest numbered file or the
            highest numbered file.
            </summary>
        </member>
        <member name="P:adimus.ertus.Logger.ExtendedRollingFileAppender.RollingStyle">
            <summary>
            Set the rolling style
            </summary>
        </member>
        <member name="P:adimus.ertus.Logger.ExtendedRollingFileAppender.StaticLogFileName">
            <summary>
            Set the m_staticLogFileName flag
            </summary>
        </member>
        <member name="T:adimus.ertus.Logger.ExtendedRollingFileAppender.RollPoint">
            <summary>
            The code assumes that the following 'time' constants are in a increasing sequence.
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.ExtendedRollingFileAppender.RollPoint.TOP_OF_TROUBLE">
            <summary>
            Roll the log not based on the date
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.ExtendedRollingFileAppender.RollPoint.TOP_OF_MINUTE">
            <summary>
            Roll the log for each minute
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.ExtendedRollingFileAppender.RollPoint.TOP_OF_HOUR">
            <summary>
            Roll the log for each hour
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.ExtendedRollingFileAppender.RollPoint.HALF_DAY">
            <summary>
            Roll the log twice a day (midday and midnight)
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.ExtendedRollingFileAppender.RollPoint.TOP_OF_DAY">
            <summary>
            Roll the log each day (midnight)
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.ExtendedRollingFileAppender.RollPoint.TOP_OF_WEEK">
            <summary>
            Roll the log each week
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.ExtendedRollingFileAppender.RollPoint.TOP_OF_MONTH">
            <summary>
            Roll the log each month
            </summary>
        </member>
        <member name="T:adimus.ertus.Logger.CountingQuietWriter">
            <summary>
            Subclass of <see cref="T:adimus.ertus.Logger.QuietStreamWriter"/> that maintains a count of 
            the number of bytes written.
            </summary>
        </member>
        <member name="T:adimus.ertus.Logger.QuietStreamWriter">
            <summary>
            QuietStreamWriter does not throw exceptions when things go wrong. 
            Instead, it delegates error handling to its <see cref="T:log4net.Core.IErrorHandler"/>.
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.QuietStreamWriter.REVISION">
            <summary>
            Revision of class as set by source control.
            </summary>		
        </member>
        <member name="F:adimus.ertus.Logger.QuietStreamWriter.errorHandler">
            <summary>
            The error handler instance to pass all errors to
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.QuietStreamWriter.closed">
            <summary>
            Flag to indicate if this writer is closed
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.QuietStreamWriter.#ctor(log4net.Core.IErrorHandler,System.String,System.Boolean)">
            <summary>
            Create a new QuietStreamWriter using a stream and error handler
            </summary>
            <param name="errorHandler">the error handler to report error to</param>
            <param name="p_fileName"></param>
            <param name="p_append"></param>
        </member>
        <member name="M:adimus.ertus.Logger.QuietStreamWriter.Write(System.String,System.Text.Encoding)">
            <summary>
            Writes a string to the output.
            </summary>
            <remarks>
            Callee should take care of any encoding and outputing to a byte format.
            </remarks>
            <param name="value">String to output</param>		
            <param name="encoding">Encoding to output string</param>
        </member>
        <member name="M:adimus.ertus.Logger.QuietStreamWriter.Close">
            <summary>
            Closes the underlying output writer.
            </summary>
        </member>
        <member name="P:adimus.ertus.Logger.QuietStreamWriter.ErrorHandler">
            <summary>
            Gets or sets the error handler that all errors are 
            passed to.
            </summary>
            <value>
            The error handler that all errors are passed to.
            </value>
        </member>
        <member name="P:adimus.ertus.Logger.QuietStreamWriter.Closed">
            <summary>
            Gets a value indicating whether this writer is closed.
            </summary>
            <value>
            <c>true</c> if this writer is closed, otherwise <c>false</c>.
            </value>
        </member>
        <member name="F:adimus.ertus.Logger.CountingQuietWriter.REVISION">
            <summary>
            Revision of class as set by source control.
            </summary>		
        </member>
        <member name="F:adimus.ertus.Logger.CountingQuietWriter.countBytes">
            <summary>
            Total number of bytes written.
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.CountingQuietWriter.#ctor(log4net.Core.IErrorHandler,System.String,System.Boolean)">
            <summary>
            Creates a new instance of the <see cref="T:adimus.ertus.Logger.CountingQuietWriter"/> class 
            with the specified <see cref="T:System.IO.FileStream"/> and <see cref="T:log4net.Core.IErrorHandler"/>.
            </summary>
            <param name="errorHandler">The <see cref="T:log4net.Core.IErrorHandler"/> to report errors to.
            <param name="p_fileName"></param>
            <param name="p_append"></param>
            </param>
        </member>
        <member name="M:adimus.ertus.Logger.CountingQuietWriter.Write(System.String,System.Text.Encoding)">
            <summary>
            Writes a string to the output and counts the number of bytes written.
            </summary>
            <param name="value">String to output</param>		
            <param name="encoding">Encoding to output string</param>
        </member>
        <member name="P:adimus.ertus.Logger.CountingQuietWriter.Count">
            <summary>
            Gets or sets the total number of bytes written.
            </summary>
            <value>
            The total number of bytes written.
            </value>
        </member>
        <member name="T:adimus.ertus.Logger.Utils.WaitableQueue`1">
            <summary>
              Efficient implementation of thread-safe waitable queue.
            </summary>
            <remarks>
              Thread starvation is possible using this queue.
              Do not use this class as general-purpose IPC when multiple threads
              are calling <see cref="M:adimus.ertus.Logger.Utils.WaitableQueue`1.Dequeue(System.Collections.Generic.List{`0},System.Int32)"/> method.
            </remarks>
        </member>
        <member name="M:adimus.ertus.Logger.Utils.WaitableQueue`1.#ctor">
            <summary>
              Initializes the queue
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.Utils.WaitableQueue`1.Dequeue(System.Collections.Generic.List{`0},System.Int32)">
            <summary>
              Returns (and removes) object from the head of the queue.
              Waits some time period if queue is empty.
            </summary>
            <param name = "p_items">List that will be filled with items from the queue</param>
            <param name = "p_Timeout">Time period to wait</param>
            <returns>Retrieved array of all items in the queue or empty array if the queue is empty</returns>
        </member>
        <member name="M:adimus.ertus.Logger.Utils.WaitableQueue`1.Dequeue(System.Collections.Generic.List{`0},System.TimeSpan)">
            <summary>
              Returns (and removes) object from the head of the queue.
              Waits some time period if queue is empty.
            </summary>
            <param name = "p_items">List that will be filled with items from the queue</param>
            <param name = "p_Timeout">Time period to wait</param>
            <returns>Retrieved object or null if queue is empty</returns>
            <remarks>
              This method uses fast and efficient method of data retrieval from queue, 
              optimized for the cases when queue is not empty most of the time. 
              Calling thread enters wait state only if queue is empty.
            </remarks>
        </member>
        <member name="M:adimus.ertus.Logger.Utils.WaitableQueue`1.Dequeue(System.Collections.Generic.List{`0})">
            <summary>
              Returns (and removes) object from the head of the queue.
              Waits indefinitely if queue is empty.
            </summary>
            <param name = "p_items">List that will be filled with items from the queue</param>
            <returns>Retrieved object</returns>
            <remarks>
              This method uses fast and efficient method of data retrieval from queue, 
              optimized for the cases when queue is not empty most of the time. 
              Calling thread enters wait state only if queue is empty.
            </remarks>
        </member>
        <member name="M:adimus.ertus.Logger.Utils.WaitableQueue`1.Enqueue(`0)">
            <summary>
              Inserts item at the tail of the queue
            </summary>
            <param name = "p_Item">Item to insert</param>
        </member>
        <member name="F:adimus.ertus.Logger.Utils.WaitableQueue`1.m_items">
            <summary>
              Item container
            </summary>
        </member>
        <member name="T:adimus.ertus.Logger.AsynchronousWriter.WaitableQueue">
            <summary>
            Efficient implementation of thread-safe waitable queue.
            </summary>
            <remarks>Thread starvation is possible using this queue.
            Do not use this class as general-purpose IPC when multiple threads
            are calling <see cref="M:adimus.ertus.Logger.AsynchronousWriter.WaitableQueue.Dequeue(System.Int32)"/> method.</remarks>
        </member>
        <member name="M:adimus.ertus.Logger.AsynchronousWriter.WaitableQueue.#ctor">
            <summary>
            Initializes the queue
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.AsynchronousWriter.WaitableQueue.Enqueue(System.Object)">
            <summary>
            Inserts item at the tail of the queue
            </summary>
            <param name="p_Item">Item to insert</param>
        </member>
        <member name="M:adimus.ertus.Logger.AsynchronousWriter.WaitableQueue.Dequeue(System.Int32)">
            <summary>
            Returns (and removes) object from the head of the queue.
            Waits some time period if queue is empty.
            </summary>
            <param name="p_Timeout">Time period to wait</param>
            <returns>Retrieved object or null if queue is empty</returns>
            <remarks>This method uses fast and efficient method of data retrieval from queue, 
            optimized for the cases when queue is not empty most of the time. 
            Calling thread enters wait state only if queue is empty.</remarks>		
        </member>
        <member name="M:adimus.ertus.Logger.AsynchronousWriter.WaitableQueue.Dequeue(System.TimeSpan)">
            <summary>
            Returns (and removes) object from the head of the queue.
            Waits some time period if queue is empty.
            </summary>
            <param name="p_Timeout">Time period to wait</param>
            <returns>Retrieved object or null if queue is empty</returns>
            <remarks>This method uses fast and efficient method of data retrieval from queue, 
            optimized for the cases when queue is not empty most of the time. 
            Calling thread enters wait state only if queue is empty.</remarks>	
        </member>
        <member name="M:adimus.ertus.Logger.AsynchronousWriter.WaitableQueue.Dequeue">
            <summary>
            Returns (and removes) object from the head of the queue.
            Waits indefinitely if queue is empty.
            </summary>	
            <returns>Retrieved object</returns>
            <remarks>This method uses fast and efficient method of data retrieval from queue, 
            optimized for the cases when queue is not empty most of the time. 
            Calling thread enters wait state only if queue is empty.</remarks>	
        </member>
        <member name="M:adimus.ertus.Logger.AsynchronousWriter.WaitableQueue.op_Implicit(adimus.ertus.Logger.AsynchronousWriter.WaitableQueue)~System.Threading.WaitHandle">
            <summary>
            Cast operator from WaitableQueue to <see cref="T:System.Threading.WaitHandle"/> 
            </summary>
            <param name="p_waitaibleQueue"></param>
            <returns>Event what can be waited for</returns>
        </member>
        <member name="M:adimus.ertus.Logger.AsynchronousWriter.WaitableQueue.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Retrieves enumerator of internal queue
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:adimus.ertus.Logger.AsynchronousWriter.WaitableQueue.AttemptDequeue">
            <summary>
            Retrieves and removed object from the head of the queue.
            Resets <see cref="F:adimus.ertus.Logger.AsynchronousWriter.WaitableQueue.m_Event"/> if last element was removed.
            </summary>
            <returns>Retrieved object or null</returns>
        </member>
        <member name="F:adimus.ertus.Logger.AsynchronousWriter.WaitableQueue.m_WrappedQueue">
            <summary>
            Item container
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.AsynchronousWriter.WaitableQueue.m_Event">
            <summary>
            Event used to wake up waiting threads.
            Event is in signalled state if queue isn't empty
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.AsynchronousWriter.WaitableQueue.log">
            <summary>
            Log4Net support
            </summary>
        </member>
        <member name="P:adimus.ertus.Logger.AsynchronousWriter.WaitableQueue.Count">
            <summary>
            Number of objects in the queue
            </summary>
            <value>Returns m_WrappedQueue.Count</value>
        </member>
        <member name="T:JetBrains.Annotations.LocalizableAttribute">
            <summary>
            Indicates that marked elements is localizable or not.
            </summary>
        </member>
        <member name="M:JetBrains.Annotations.LocalizableAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:JetBrains.Annotations.LocalizableAttribute"/> class.
            </summary>
            <param name="isLocalizable"><c>true</c> if a element should be localized; otherwise, <c>false</c>.</param>
        </member>
        <member name="M:JetBrains.Annotations.LocalizableAttribute.Equals(System.Object)">
            <summary>
            Returns whether the value of the given object is equal to the current <see cref="T:JetBrains.Annotations.LocalizableAttribute"/>.
            </summary>
            <param name="obj">The object to test the value equality of. </param>
            <returns>
            <c>true</c> if the value of the given object is equal to that of the current; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:JetBrains.Annotations.LocalizableAttribute.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>A hash code for the current <see cref="T:JetBrains.Annotations.LocalizableAttribute"/>.</returns>
        </member>
        <member name="P:JetBrains.Annotations.LocalizableAttribute.IsLocalizable">
            <summary>
            Gets a value indicating whether a element should be localized.
            <value><c>true</c> if a element should be localized; otherwise, <c>false</c>.</value>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.StringFormatMethodAttribute">
            <summary>
            Indicates that marked method builds string by format pattern and (optional) arguments. 
            Parameter, which contains format string, should be given in constructor.
            The format string should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/> -like form
            </summary>
        </member>
        <member name="M:JetBrains.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <summary>
            Initializes new instance of StringFormatMethodAttribute
            </summary>
            <param name="formatParameterName">Specifies which parameter of an annotated method should be treated as format-string</param>
        </member>
        <member name="P:JetBrains.Annotations.StringFormatMethodAttribute.FormatParameterName">
            <summary>
            Gets format parameter name
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be string literal and match one  of the parameters of the caller function.
            For example, <see cref="T:System.ArgumentNullException"/> has such parameter.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AssertionMethodAttribute">
            <summary>
            Indicates that the marked method is assertion method, i.e. it halts control flow if one of the conditions is satisfied. 
            To set the condition, mark one of the parameters with <see cref="T:JetBrains.Annotations.AssertionConditionAttribute"/> attribute
            </summary>
            <seealso cref="T:JetBrains.Annotations.AssertionConditionAttribute"/>
        </member>
        <member name="T:JetBrains.Annotations.AssertionConditionAttribute">
            <summary>
            Indicates the condition parameter of the assertion method. 
            The method itself should be marked by <see cref="T:JetBrains.Annotations.AssertionMethodAttribute"/> attribute.
            The mandatory argument of the attribute is the assertion type.
            </summary>
            <seealso cref="T:JetBrains.Annotations.AssertionConditionType"/>
        </member>
        <member name="M:JetBrains.Annotations.AssertionConditionAttribute.#ctor(JetBrains.Annotations.AssertionConditionType)">
            <summary>
            Initializes new instance of AssertionConditionAttribute
            </summary>
            <param name="conditionType">Specifies condition type</param>
        </member>
        <member name="P:JetBrains.Annotations.AssertionConditionAttribute.ConditionType">
            <summary>
            Gets condition type
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.AssertionConditionType">
            <summary>
            Specifies assertion type. If the assertion method argument satisifes the condition, then the execution continues. 
            Otherwise, execution is assumed to be halted
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_TRUE">
            <summary>
            Indicates that the marked parameter should be evaluated to true
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_FALSE">
            <summary>
            Indicates that the marked parameter should be evaluated to false
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_NULL">
            <summary>
            Indicates that the marked parameter should be evaluated to null value
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.AssertionConditionType.IS_NOT_NULL">
            <summary>
            Indicates that the marked parameter should be evaluated to not null value
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.TerminatesProgramAttribute">
            <summary>
            Indicates that the marked method unconditionally terminates control flow execution.
            For example, it could unconditionally throw exception
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.CanBeNullAttribute">
            <summary>
            Indicates that the value of marked element could be <c>null</c> sometimes, so the check for <c>null</c> is necessary before its usage
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.NotNullAttribute">
            <summary>
            Indicates that the value of marked element could never be <c>null</c>
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.CannotApplyEqualityOperatorAttribute">
            <summary>
            Indicates that the value of marked type (or its derivatives) cannot be compared using '==' or '!=' operators.
            There is only exception to compare with <c>null</c>, it is permitted
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.BaseTypeRequiredAttribute">
            <summary>
            When applied to target attribute, specifies a requirement for any type which is marked with 
            target attribute to implement or inherit specific type or types
            </summary>
            <example>
            <code>
            [BaseTypeRequired(typeof(IComponent)] // Specify requirement
            public class ComponentAttribute : Attribute 
            {}
            
            [Component] // ComponentAttribute requires implementing IComponent interface
            public class MyComponent : IComponent
            {}
            </code>
            </example>
        </member>
        <member name="M:JetBrains.Annotations.BaseTypeRequiredAttribute.#ctor(System.Type[])">
            <summary>
            Initializes new instance of BaseTypeRequiredAttribute
            </summary>
            <param name="baseTypes">Specifies which types are required</param>
        </member>
        <member name="P:JetBrains.Annotations.BaseTypeRequiredAttribute.BaseTypes">
            <summary>
            Gets enumerations of specified base types
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.UsedImplicitlyAttribute">
            <summary>
            Indicates that the marked symbol is used implicitly (e.g. via reflection, in external library),
            so this symbol will not be marked as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="M:JetBrains.Annotations.UsedImplicitlyAttribute.#ctor">
            <summary>
            Initializes new instance of UsedImplicitlyAttribute
            </summary>
        </member>
        <member name="M:JetBrains.Annotations.UsedImplicitlyAttribute.#ctor(JetBrains.Annotations.ImplicitUseFlags)">
            <summary>
            Initializes new instance of UsedImplicitlyAttribute with specified flags
            </summary>
            <param name="flags">Value of type <see cref="T:JetBrains.Annotations.ImplicitUseFlags"/> indicating usage kind</param>
        </member>
        <member name="P:JetBrains.Annotations.UsedImplicitlyAttribute.Flags">
            <summary>
            Gets value indicating what is meant to be used
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.MeansImplicitUseAttribute">
            <summary>
            Should be used on attributes and causes ReSharper to not mark symbols marked with such attributes as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="M:JetBrains.Annotations.MeansImplicitUseAttribute.#ctor">
            <summary>
            Initializes new instance of MeansImplicitUseAttribute
            </summary>
        </member>
        <member name="M:JetBrains.Annotations.MeansImplicitUseAttribute.#ctor(JetBrains.Annotations.ImplicitUseFlags)">
            <summary>
            Initializes new instance of MeansImplicitUseAttribute with specified flags
            </summary>
            <param name="flags">Value of type <see cref="T:JetBrains.Annotations.ImplicitUseFlags"/> indicating usage kind</param>
        </member>
        <member name="P:JetBrains.Annotations.MeansImplicitUseAttribute.Flags">
            <summary>
            Gets value indicating what is meant to be used
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.ImplicitUseFlags">
            <summary>
            Specify what is considered used implicitly when marked with <see cref="T:JetBrains.Annotations.MeansImplicitUseAttribute"/> or <see cref="T:JetBrains.Annotations.UsedImplicitlyAttribute"/>
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseFlags.Access">
            <summary>
            Only entity marked with attribute considered used
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseFlags.Initialize">
            <summary>
            Indicates implicit intialization of a member
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseFlags.IncludeMembers">
            <summary>
            Entity marked with attribute and all its members considered used
            </summary>
        </member>
        <member name="T:adimus.ertus.Logger.Logging">
            <summary>
              This class supplies 2 wrapping methods that generate a string to log and pass it to the logger.
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.Logging.GetLogger``1">
            <summary>
              Gets the logger for a given type. This method supports generic types.
            </summary>
            <typeparam name = "T">The type will be used for the name of the logger to retrieve.</typeparam>
            <returns>The logger for the given type.</returns>
        </member>
        <member name="M:adimus.ertus.Logger.Logging.InitFromConfigFile">
            <summary>
              Initialize the logging ertusstructure. In particular, initialize the configuration file.
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.Logging.InitFromConfigFile(System.String)">
            <summary>
              Initialize the logging ertusstructure. In particular, initialize the configuration file.
            </summary>
        </member>
        <member name="M:adimus.ertus.Logger.Logging.Log(log4net.ILog,adimus.ertus.Logger.Severity,System.String,System.Object[])">
            <summary>
              Log a given set of parameters with a given format.
            </summary>
            <param name = "p_logger">
              Logger object.
            </param>
            <param name = "p_severity">
              The severity level to log at.
            </param>
            <param name = "p_fmt">
              The string format.
            </param>
            <param name = "p_parameters">
              Array of parameters to be formatted as string.
            </param>
        </member>
        <member name="M:adimus.ertus.Logger.Logging.Log(log4net.ILog,adimus.ertus.Logger.Severity,System.String)">
            <summary>
              Log a given set of parameters with a given format.
            </summary>
            <param name = "p_logger">
              Logger object.
            </param>
            <param name = "p_severity">
              The severity level to log at.
            </param>
            <param name = "p_msg">
              The string message.
            </param>
        </member>
        <member name="M:adimus.ertus.Logger.Logging.Log(log4net.ILog,adimus.ertus.Logger.Severity,System.Exception,System.String,System.Object[])">
            <summary>
              Log a given set of parameters with a given format.
            </summary>
            <param name = "p_logger">
              Logger object.
            </param>
            <param name = "p_severity">
              The severity level to log at.
            </param>
            <param name = "p_exception">
              An exception to document.
            </param>
            <param name = "p_fmt">
              The string format.
            </param>
            <param name = "p_parameters">
              Array of parameters to be formatted as string.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:adimus.ertus.Logger.Logging.Log(log4net.ILog,adimus.ertus.Logger.Severity,System.Exception,System.String)" -->
        <member name="T:adimus.ertus.Logger.Severity">
            <summary>
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.Severity.Debug">
            <summary>
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.Severity.Info">
            <summary>
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.Severity.Warn">
            <summary>
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.Severity.Error">
            <summary>
            </summary>
        </member>
        <member name="F:adimus.ertus.Logger.Severity.Fatal">
            <summary>
            </summary>
        </member>
    </members>
</doc>
